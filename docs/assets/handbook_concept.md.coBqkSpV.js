import{_ as e,c as t,o as s,V as n,aq as a}from"./chunks/framework.ITQiifkM.js";const g=JSON.parse('{"title":"Concept","description":"PURISTA typescript backend framework concept","frontmatter":{"title":"Concept","description":"PURISTA typescript backend framework concept","order":10},"headers":[],"relativePath":"handbook/concept.md","filePath":"handbook/concept.md","lastUpdated":1708207057000}'),i={name:"handbook/concept.md"},o=n('<h1 id="purista-concept" tabindex="-1">PURISTA Concept <a class="header-anchor" href="#purista-concept" aria-label="Permalink to &quot;PURISTA Concept&quot;">​</a></h1><p>PURISTA operates on a straightforward message-based system. In this system, there are message senders and receivers. Messages are passed through an event bridge, which connects to a message broker.</p><p>The heart of PURISTA&#39;s logic lies in its Services, which follow the principles of Domain-Driven Design (DDD). Each Service represents a logical grouping of commands and subscriptions that pertain to a specific domain.</p><p>Commands are active actions triggered by an external source. When a command is invoked, the caller expects a response. Think of commands as similar to functions in traditional programming languages. The caller knows about the command&#39;s existence, its input and output formats, and potentially error responses. However, the caller doesn&#39;t need to understand how the command is implemented or executed, nor does it need to know which instance of the service is handling the request.</p><p>On the other hand, Subscriptions are passive listeners. When a message matches the criteria defined by a subscription, the subscription is triggered. Importantly, the producer of the message isn&#39;t aware of any subscriptions that may be listening.</p><p>Commands and subscriptions can invoke other commands within the same or different services by sending command messages. This creates a structured and unified internal interface that allows for clean communication between components. Additionally, this setup provides built-in error handling capabilities, making the system both observable and traceable.</p><p>By leveraging this architecture, PURISTA enables the creation of complex setups and scenarios with ease.</p><h2 id="example" tabindex="-1">Example <a class="header-anchor" href="#example" aria-label="Permalink to &quot;Example&quot;">​</a></h2><p>We will use a simple example for better understanding.</p><p><img src="'+a+'" alt="example"></p><ul><li>the browser calls the endpoint <code>/api/v1/sign-up</code></li><li>the web server will send a command request <code>userSignUp</code> to the event bridge, which is received by an instance of service <code>User</code></li><li>the command <code>userSignUp</code> is responding to the web server with the ID of this new created user via the event bridge</li><li>the response of command <code>userSignUp</code> is marked with the event name <code>newUserRegistered</code></li><li>the web server will receive the response command <code>userSignUp</code> and sends the response back to the browsers</li><li>the service <code>Email</code> has a subscription <code>sendWelcomeEmail</code> which is listening to all successful calls to <code>newUserRegistered</code> command</li><li>the subscription <code>sendWelcomeEmail</code> in service <code>Email</code> connects to the mail provider and sends the email</li></ul><p>Each of these steps is only one single and simple function, which is easy to implement, to understand and to test. Each of these steps has input-output-validation in place. Each step has its own error handling and responses are divided into success and error response. Each step is decoupled from the others.</p><p>The different services can be implemented by different developers, which are able to work independently on their feature.</p>',13),r=[o];function c(d,p,l,h,m,u){return s(),t("div",null,r)}const f=e(i,[["render",c]]);export{g as __pageData,f as default};
