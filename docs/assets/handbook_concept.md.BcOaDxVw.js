import{_ as e,c as s,o as t,V as a,aq as o}from"./chunks/framework.ITQiifkM.js";const g=JSON.parse('{"title":"Concept","description":"PURISTA typescript backend framework concept","frontmatter":{"title":"Concept","description":"PURISTA typescript backend framework concept","order":10},"headers":[],"relativePath":"handbook/concept.md","filePath":"handbook/concept.md","lastUpdated":1706444636000}'),n={name:"handbook/concept.md"},i=a('<h1 id="purista-concept" tabindex="-1">PURISTA Concept <a class="header-anchor" href="#purista-concept" aria-label="Permalink to &quot;PURISTA Concept&quot;">​</a></h1><p>The concept behind PURISTA is quite simple and a message based approach. There are message senders and receivers. Messages are exchanged via an event bridge, which is connected to some kind of message broker.</p><p>The logic resists in Service. They are the DDD part. A service is a logical group of commands and subscriptions which relate to a single domain.</p><p>Commands are active, triggered by someone, and the caller expects some kind of result. This is similar to functions in any programming language. It means the caller knows about the existence of the called service &amp; command, and he knows at least the input and output format and maybe something about possible error responses. How the called command function is implemented or how it works is unknown and not related to the caller. Also, the caller does not know which instance is handling the requests.</p><p>Subscriptions are a passive part, like event listeners. A subscription is triggered as soon as a message matches the subscription criteria. The producer of this message does not have knowledge about this subscription.</p><p>Commands and subscription can call other commands from same or other service by sending command messages. This means, there is a clean, structured and unified internal interface, which is also observable and traceable with error handling out of the box.</p><p>This allows real complex setups and scenarios.</p><h2 id="example" tabindex="-1">Example <a class="header-anchor" href="#example" aria-label="Permalink to &quot;Example&quot;">​</a></h2><p>We will use a simple example for better understanding.</p><p><img src="'+o+'" alt="example"></p><ul><li>the browser calls the endpoint <code>/api/v1/sign-up</code></li><li>the web server will send a command request <code>userSignUp</code> to the event bridge, which is received by an instance of service <code>User</code></li><li>the command <code>userSignUp</code> is responding to the web server with the ID of this new created user via the event bridge</li><li>the response of command <code>userSignUp</code> is marked with the event name <code>newUserRegistered</code></li><li>the web server will receive the response command <code>userSignUp</code> and sends the response back to the browsers</li><li>the service <code>Email</code> has a subscription <code>sendWelcomeEmail</code> which is listening to all successful calls to <code>newUserRegistered</code> command</li><li>the subscription <code>sendWelcomeEmail</code> in service <code>Email</code> connects to the mail provider and sends the email</li></ul><p>Each of these steps is only one single and simple function, which is easy to implement, to understand and to test. Each of these steps has input-output-validation in place. Each step has its own error handling and responses are divided into success and error response. Each step is decoupled from the others.</p><p>The different services can be implemented by different developers, which are able to work independently on their feature.</p>',13),r=[i];function c(d,l,p,h,m,u){return t(),s("div",null,r)}const f=e(n,[["render",c]]);export{g as __pageData,f as default};
